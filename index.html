<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic 3D - Point to Zoom</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #ui { position: absolute; bottom: 5%; width: 100%; text-align: center; color: white; z-index: 10; pointer-events: none; }
        button { padding: 15px 40px; pointer-events: auto; cursor: pointer; background: #cc0000; color: white; border: 2px solid gold; border-radius: 50px; }
        #video-in { position: absolute; top: 10px; right: 10px; width: 150px; border-radius: 10px; transform: scaleX(-1); }
        .guide { background: rgba(0,0,0,0.5); padding: 10px; border-radius: 10px; display: inline-block; }
    </style>
</head>
<body>

    <video id="video-in" autoplay playsinline></video>
    <div id="container"></div>

    <div id="ui">
        <div class="guide">
            ‚òùÔ∏è <b>Ch·ªâ 1 ng√≥n:</b> Ph√≥ng to ·∫£nh | üñêÔ∏è <b>X√≤e tay:</b> N·ªï tung | ‚úä <b>N·∫Øm tay:</b> Thu v·ªÅ
        </div><br><br>
        <button id="startBtn">B·∫ÆT ƒê·∫¶U</button>
    </div>

    <script>
        let scene, camera, renderer, hands, cameraFeed;
        let photoMeshes = [], magicDust;
        let state = 'TREE'; // TREE, EXPLODE, POINTING
        let handX = 0.5, handY = 0.5, fingerX = 0, fingerY = 0;
        let focusedMesh = null;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function initScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 2000);
            camera.position.z = 250;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 1));
            
            // T·∫°o b·ª•i sao lung linh
            const dustGeo = new THREE.BufferGeometry();
            const dustPos = [];
            for(let i=0; i<2000; i++) dustPos.push((Math.random()-0.5)*800, (Math.random()-0.5)*800, (Math.random()-0.5)*800);
            dustGeo.setAttribute('position', new THREE.Float32BufferAttribute(dustPos, 3));
            magicDust = new THREE.Points(dustGeo, new THREE.PointsMaterial({color: 0xFFD700, size: 1.5, transparent: true, opacity: 0.6}));
            scene.add(magicDust);

            createForest();
            animate();
        }

        function createForest() {
            const geo = new THREE.PlaneGeometry(12, 16);
            for (let i = 1; i <= 31; i++) {
                const mat = new THREE.MeshBasicMaterial({ 
                    map: new THREE.TextureLoader().load(`public/photos/${i}.jpg`), 
                    side: THREE.DoubleSide, transparent: true, opacity: 0 
                });
                const mesh = new THREE.Mesh(geo, mat);
                
                const t = i / 31;
                const angle = i * 0.9;
                const radius = t * 60;
                mesh.userData.treePos = new THREE.Vector3(Math.cos(angle)*radius, (1-t)*120-60, Math.sin(angle)*radius);
                mesh.userData.explodePos = new THREE.Vector3((Math.random()-0.5)*400, (Math.random()-0.5)*400, (Math.random()-0.5)*300);
                
                mesh.position.copy(mesh.userData.treePos);
                scene.add(mesh);
                photoMeshes.push(mesh);
            }
        }

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                
                // 1. Nh·∫≠n di·ªán c√°c t∆∞ th·∫ø tay
                const isIndexUp = lm[8].y < lm[6].y;
                const isOtherDown = lm[12].y > lm[10].y && lm[16].y > lm[14].y;
                const isFist = lm[8].y > lm[6].y && lm[12].y > lm[10].y;

                if (isIndexUp && isOtherDown) {
                    state = 'POINTING';
                    // T·ªça ƒë·ªô ng√≥n tr·ªè (l·∫≠t X v√¨ webcam b·ªã ng∆∞·ª£c)
                    fingerX = (1 - lm[8].x) * 2 - 1;
                    fingerY = (1 - lm[8].y) * 2 - 1;
                } else if (isFist) {
                    state = 'TREE';
                } else {
                    state = 'EXPLODE';
                }

                handX = lm[9].x; handY = lm[9].y;
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            // Camera follow tay m∆∞·ª£t m√†
            camera.position.x += ((handX - 0.5) * 200 - camera.position.x) * 0.05;
            camera.position.y += ((0.5 - handY) * 100 - camera.position.y) * 0.05;
            camera.lookAt(0, 0, 0);

            // Logic Raycaster khi Pointing
            if (state === 'POINTING') {
                mouse.set(fingerX, fingerY);
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(photoMeshes);
                focusedMesh = intersects.length > 0 ? intersects[0].object : null;
            } else {
                focusedMesh = null;
            }

            photoMeshes.forEach((mesh) => {
                const isTree = (state === 'TREE');
                const isFocus = (mesh === focusedMesh);
                
                // V·ªã tr√≠ m·ª•c ti√™u
                const targetPos = isTree ? mesh.userData.treePos : mesh.userData.explodePos;
                
                // N·∫øu ƒëang ƒë∆∞·ª£c Point, n√≥ s·∫Ω bay v·ªÅ ph√≠a camera m·ªôt ch√∫t ƒë·ªÉ Zoom
                if (isFocus) {
                    const zoomPos = new THREE.Vector3().lerpVectors(mesh.position, camera.position, 0.4);
                    mesh.position.lerp(zoomPos, 0.1);
                    mesh.rotation.y += 0.1; // Xoay nhanh khi focus
                    mesh.material.opacity = 1;
                    mesh.scale.lerp(new THREE.Vector3(2, 2, 2), 0.1);
                } else {
                    mesh.position.lerp(targetPos, 0.07);
                    mesh.material.opacity += ((isTree ? 0.2 : 1) - mesh.material.opacity) * 0.1;
                    mesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                    
                    if (isTree) mesh.lookAt(0, mesh.position.y, 0);
                    else { mesh.rotation.x += 0.01; mesh.rotation.y += 0.01; }
                }
            });

            magicDust.rotation.y += 0.001;
            renderer.render(scene, camera);
        }

        function initMediaPipe() {
            hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5 });
            hands.onResults(onResults);
            cameraFeed = new Camera(document.getElementById('video-in'), {
                onFrame: async () => { await hands.send({ image: document.getElementById('video-in') }); },
                width: 640, height: 480
            });
            cameraFeed.start();
        }

        document.getElementById('startBtn').onclick = () => {
            document.getElementById('ui').style.display = 'none';
            initScene();
            initMediaPipe();
        };
    </script>
</body>
</html>
