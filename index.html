<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic 3D Tree - Final Version</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: radial-gradient(circle, #1a1a1a, #000); font-family: sans-serif; }
        #ui { position: absolute; bottom: 5%; width: 100%; text-align: center; color: white; z-index: 10; pointer-events: none; }
        button { padding: 15px 40px; pointer-events: auto; cursor: pointer; background: #e60000; color: white; border: 2px solid #ffd700; border-radius: 50px; font-weight: bold; box-shadow: 0 0 15px rgba(255,0,0,0.5); }
        #video-in { position: absolute; top: 10px; right: 10px; width: 150px; border-radius: 10px; transform: scaleX(-1); border: 2px solid #ffd700; z-index: 5; }
        .guide { background: rgba(0,0,0,0.7); padding: 12px 25px; border-radius: 30px; display: inline-block; border: 1px solid #ffd700; font-size: 14px; }
    </style>
</head>
<body>

    <video id="video-in" autoplay playsinline></video>
    <div id="container"></div>

    <div id="ui">
        <div class="guide">
            üëå <b>D·∫•u OK:</b> Soi ·∫£nh g·∫ßn nh·∫•t | üñêÔ∏è <b>X√≤e tay:</b> N·ªï tung | ‚úä <b>N·∫Øm tay:</b> Thu v·ªÅ
        </div><br><br>
        <button id="startBtn">KH√ÅM PH√Å NGAY</button>
    </div>

    <audio id="music" loop>
        <source src="audio.mp3" type="audio/mpeg">
    </audio>

    <script>
        let scene, camera, renderer, hands, cameraFeed;
        let photoMeshes = [], magicDust, star;
        let state = 'TREE'; 
        let handX = 0.5, handY = 0.5, okTargetX = 0, okTargetY = 0;
        let focusedMesh = null;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function initScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 2000);
            camera.position.z = 250;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 1.2));
            
            createStar(); 
            createMagicDust();
            createForest();
            animate();
        }

        function createStar() {
            const shape = new THREE.Shape();
            const pts = 5, outR = 15, inR = 7;
            for (let i = 0; i < pts * 2; i++) {
                const r = i % 2 === 0 ? outR : inR;
                const a = (i / pts) * Math.PI;
                const x = Math.cos(a) * r, y = Math.sin(a) * r;
                if (i === 0) shape.moveTo(x, y); else shape.lineTo(x, y);
            }
            const geometry = new THREE.ExtrudeGeometry(shape, { depth: 4, bevelEnabled: true, bevelSize: 2 });
            const material = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.9, roughness: 0.1 });
            star = new THREE.Mesh(geometry, material);
            star.position.y = 85;
            scene.add(star);
        }

        function createMagicDust() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<3500; i++) pos.push((Math.random()-0.5)*1000, (Math.random()-0.5)*1000, (Math.random()-0.5)*1000);
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            magicDust = new THREE.Points(geo, new THREE.PointsMaterial({color: 0xFFD700, size: 1.2, transparent: true, opacity: 0.8}));
            scene.add(magicDust);
        }

        function createForest() {
            const geo = new THREE.PlaneGeometry(12, 16);
            for (let i = 1; i <= 31; i++) {
                const mat = new THREE.MeshBasicMaterial({ 
                    map: new THREE.TextureLoader().load(`public/photos/${i}.jpg`), 
                    side: THREE.DoubleSide, transparent: true, opacity: 0 
                });
                const mesh = new THREE.Mesh(geo, mat);
                const t = i / 31, angle = i * 0.9, r = t * 65;
                mesh.userData.treePos = new THREE.Vector3(Math.cos(angle)*r, (1-t)*130-60, Math.sin(angle)*r);
                mesh.userData.explodePos = new THREE.Vector3((Math.random()-0.5)*450, (Math.random()-0.5)*450, (Math.random()-0.5)*350);
                mesh.position.copy(mesh.userData.treePos);
                scene.add(mesh);
                photoMeshes.push(mesh);
            }
        }

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                
                // Nh·∫≠n di·ªán OK: Ng√≥n c√°i (4) ch·∫°m ng√≥n tr·ªè (8)
                const dx = lm[4].x - lm[8].x, dy = lm[4].y - lm[8].y, dz = lm[4].z - lm[8].z;
                const distOK = Math.sqrt(dx*dx + dy*dy + dz*dz);
                const isOK = distOK < 0.08; 
                const isFist = lm[12].y > lm[10].y && lm[16].y > lm[14].y && lm[8].y > lm[6].y;

                if (isOK) {
                    state = 'OK_ZOOM';
                    // T·ªça ƒë·ªô chu·∫©n Raycaster (L·∫≠t X)
                    okTargetX = -(lm[4].x + lm[8].x) + 1; 
                    okTargetY = -(lm[4].y + lm[8].y) + 1; 
                } else if (isFist) {
                    state = 'TREE';
                } else {
                    state = 'EXPLODE';
                }
                handX = lm[9].x; handY = lm[9].y;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if (star) star.rotation.y += 0.04;
            if (magicDust) magicDust.rotation.y += 0.0005;

            camera.position.x += ((handX - 0.5) * 220 - camera.position.x) * 0.05;
            camera.position.y += ((0.5 - handY) * 120 - camera.position.y) * 0.05;
            camera.lookAt(0, 0, 0);

            if (state === 'OK_ZOOM') {
                mouse.set(okTargetX, okTargetY);
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(photoMeshes);
                focusedMesh = intersects.length > 0 ? intersects[0].object : null;
            } else { focusedMesh = null; }

            photoMeshes.forEach((mesh) => {
                const isTree = (state === 'TREE');
                const isFocus = (mesh === focusedMesh && state === 'OK_ZOOM');
                const targetPos = isTree ? mesh.userData.treePos : mesh.userData.explodePos;
                
                if (isFocus) {
                    const zoomPos = new THREE.Vector3().lerpVectors(mesh.position, camera.position, 0.6);
                    mesh.position.lerp(zoomPos, 0.15);
                    mesh.scale.lerp(new THREE.Vector3(2.5, 2.5, 2.5), 0.15);
                    mesh.material.opacity = 1;
                    mesh.rotation.y += 0.1;
                } else {
                    mesh.position.lerp(targetPos, 0.07);
                    const baseOp = isTree ? 0.15 : 1;
                    mesh.material.opacity += (baseOp - mesh.material.opacity) * 0.1;
                    mesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                    if (isTree) mesh.lookAt(0, mesh.position.y, 0);
                    else { mesh.rotation.x += 0.01; mesh.rotation.y += 0.01; }
                }
            });
            renderer.render(scene, camera);
        }

        function initMediaPipe() {
            hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6 });
            hands.onResults(onResults);
            cameraFeed = new Camera(document.getElementById('video-in'), {
                onFrame: async () => { await hands.send({ image: document.getElementById('video-in') }); },
                width: 640, height: 480
            });
            cameraFeed.start();
        }

        document.getElementById('startBtn').onclick = () => {
            const music = document.getElementById('music');
            music.play().catch(() => console.log("C·∫ßn t∆∞∆°ng t√°c ƒë·ªÉ ph√°t nh·∫°c"));
            document.getElementById('ui').style.display = 'none';
            initScene();
            initMediaPipe();
        };
    </script>
</body>
</html>
